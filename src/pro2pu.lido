/* TODO: fully qualify class / type names */
/* TODO: add note to PUML if there have been errors parsing .proto */
/* DONE: syntax level 3 */
/* TODO: collect groups -> ignored */
/* DONE: collect oneof  */
/* DONE: collect map    */
/* DONE: remove package if no package is given */
/* TODO: clp for include directories */
/* DONT: collect depedencies between imported packages */
/* TODO: replace add in SYMBOL ProtoDoc
 * ---> can there be multiple packages per file? --> print error
 * ---> what if file has multiple packages
 * ---> move packageless into "default" package */
/* DONE: collect type name */
/* TODO: test type name collection with dotted type names */
/* TODO: move relations to end of puml file */

/* W S L */

/**********/

CHAIN puml_ptg_chn: PTGNode;             /* collect message / enum decls */
CHAIN puml_fields_ptg_chn: PTGNode;      /* collect fields within decls */
CHAIN puml_relations_ptg_chn: PTGNode;   /* collect nesting relations */ 
CHAIN custom_types_env_chn: Environment; /* collect type names */
CHAIN qualified_classname_ptg_chn: PTGNode; /* pass down segments for qualified pathname */

CLASS SYMBOL ROOTCLASS: custom_types: Environment SYNT;
CLASS SYMBOL ROOTCLASS COMPUTE

  /* start collecting uml lines */
  CHAINSTART HEAD.puml_ptg_chn = PTGNULL;
  CHAINSTART HEAD.puml_fields_ptg_chn = PTGNULL;
  CHAINSTART HEAD.puml_relations_ptg_chn = PTGNULL;
  /* print collected uml lines */
  PTGOut(
    PTGPUML(
      PTGNlSeq( TAIL.puml_ptg_chn, TAIL.puml_relations_ptg_chn )
  ));

  /** TODO: collect full qualified path instead of just the name */
  CHAINSTART HEAD.custom_types_env_chn = NewEnv();
  SYNT.custom_types = TAIL.custom_types_env_chn;
END;

SYMBOL ProtoDoc: package_name: int SYNT;
SYMBOL ProtoDoc COMPUTE
  SYNT.puml_ptg_chn = PTGNlSeq(THIS.puml_ptg_chn,
                      PTGNlSeq(%// wrap into package only if there is a package name given
                               IF ( THIS.package_name %// is not null
                                  , PTGPackage( CONSTITUENTS Package.name WITH (int,ior_package,IDENTICAL,ZERO)
                                              , TAIL.puml_ptg_chn )
                                  , PTGNoPackage( TAIL.puml_ptg_chn )
                                  )
                              , PTGNULL /*TAIL.puml_relations_ptg_chn*/
                              ));

  HEAD.puml_ptg_chn = PTGNULL;
  HEAD.puml_fields_ptg_chn = PTGNULL;
  /*HEAD.puml_relations_ptg_chn = PTGNULL;*/ %// propagate all relations through the end

  %// pull up package name to document root
  SYNT.package_name = CONSTITUENTS Package.name WITH (int,ior_package,IDENTICAL,ZERO);

  %// hand down type qualifier, start with package name
  CHAINSTART HEAD.qualified_classname_ptg_chn = IF( THIS.package_name, PTGId(THIS.package_name), PTGNULL );
END;

CLASS SYMBOL hasName: name: int SYNT;
SYMBOL Package INHERITS hasName END;
SYMBOL Message INHERITS hasName END;
SYMBOL Enum    INHERITS hasName END;
SYMBOL OneOf   INHERITS hasName END;


RULE rPackage: Package ::= PackageName COMPUTE
  Package.name = PackageName.sym;
END;
SYMBOL Package COMPUTE
  /*SYNT.puml_ptg_chn = PTGPackage(CONSITUTENT PackageName.sym, TAIL.puml_ptg_chn);*/

  /*TODO: handle multiple packages and imports */
  /*HEAD.puml_relations_ptg_chn = PTGNULL;*/  
END;


CLASS SYMBOL qualifiedName: qualified_name_ptg: PTGNode SYNT;
CLASS SYMBOL qualifiedName COMPUTE
  SYNT.qualified_name_ptg = PTGDotSeq(THIS.qualified_classname_ptg_chn, PTGId(THIS.name));

  %// dont refine class scope, because plantuml can handle only 1 level of scopes
  %// HEAD.qualified_classname_ptg_chn = THIS.qualified_name_ptg;
  %// SYNT.qualified_classname_ptg_chn = THIS.qualified_classname_ptg_chn; %// bridge
END;

SYMBOL Message INHERITS qualifiedName END;
SYMBOL Enum    INHERITS qualifiedName END;
/* SYMBOL Extend  INHERITS qualifiedName END; /* TODO: some Eli error with overrides not recognized? */

SYMBOL Extend: qualified_name_ptg: PTGNode SYNT;
SYMBOL Extend COMPUTE
  /* must override in SYMBOL, not in RULE */
  SYNT.qualified_name_ptg = PTGDotSeq(THIS.qualified_classname_ptg_chn, PTGId(THIS.messageType));

  %// dont refine class scope, because plantuml can handle only 1 level of scopes
  %// HEAD.qualified_classname_ptg_chn = THIS.qualified_name_ptg;
  %// SYNT.qualified_classname_ptg_chn = THIS.qualified_classname_ptg_chn; %// bridge
END;


RULE rMessage: Message ::= MessageName MessageBody COMPUTE
  /* declares a new type of .name */
  Message.name = MessageName.sym;
END;
SYMBOL Message COMPUTE
  /*printf("DEBUG: looking at message %s\n",StringTable(THIS.name));*/
  /* pass empty chain down, let subtree fill it  */
  HEAD.puml_fields_ptg_chn = PTGNULL;
  /* bridge fields over subtree, in case of nested messages */
  SYNT.puml_fields_ptg_chn = THIS.puml_fields_ptg_chn;

  %//SYNT.puml_ptg_chn = PTGNlSeq(TAIL.puml_ptg_chn, PTGClass(THIS.name, TAIL.puml_fields_ptg_chn));
  SYNT.puml_ptg_chn = PTGNlSeq(TAIL.puml_ptg_chn, PTGClass(THIS.qualified_name_ptg, TAIL.puml_fields_ptg_chn));

  HEAD.custom_types_env_chn = EnvOf(BindKey(THIS.custom_types_env_chn, THIS.name,
                                    KResetQualifiedName(NewKey(), THIS.qualified_name_ptg)));

END;


RULE rEnum: Enum ::= EnumName EnumBody COMPUTE
  Enum.name = EnumName.sym;
END;
SYMBOL Enum COMPUTE
/* pass empty chain down, let subtree fill it  */
  HEAD.puml_fields_ptg_chn = PTGNULL;
  /* bridge fields over subtree, in case of nested messages */
  SYNT.puml_fields_ptg_chn = THIS.puml_fields_ptg_chn;

  /* bridge over subtree */
  %//SYNT.puml_ptg_chn = PTGNlSeq(TAIL.puml_ptg_chn, PTGEnum(THIS.name, TAIL.puml_fields_ptg_chn));
  SYNT.puml_ptg_chn = PTGNlSeq(TAIL.puml_ptg_chn, PTGEnum(THIS.qualified_name_ptg, TAIL.puml_fields_ptg_chn));

  HEAD.custom_types_env_chn = EnvOf(BindKey(THIS.custom_types_env_chn, THIS.name,
                                    KResetQualifiedName(NewKey(), THIS.qualified_name_ptg)));

END;


SYMBOL Extend: messageType: int SYNT;
RULE rExtend: Extend ::= MessageType ExtendBody COMPUTE
  Extend.messageType = MessageType.sym;
END;



CLASS SYMBOL contributesField: field_ptg: PTGNode SYNT;
CLASS SYMBOL contributesField: field_relation_ptg: PTGNode SYNT; %// is PTGNULL if type is primitve
CLASS SYMBOL contributesField COMPUTE
  %// contribution to chain
  SYNT.puml_fields_ptg_chn =
    PTGNlSeq(THIS.puml_fields_ptg_chn, THIS.field_ptg);

  %// add a type relation of parent uses fieldtype
  SYNT.puml_relations_ptg_chn =
    PTGNlSeq(THIS.puml_relations_ptg_chn, THIS.field_relation_ptg);
END;

SYMBOL Field INHERITS contributesField END;
SYMBOL Map   INHERITS contributesField END;
SYMBOL OneOf INHERITS contributesField END;
%// OneOfField does NOT INHERITS contributesField, because OneOf forms a wrapper around it

%// get qualfied name; if none found, default to key as type
%// TODO: recognized already-qualified names being used as keys
#define lazy_GetQualifiedName(KEY,DFLT_SYM,MESG) \
  IF( HasQualifiedName(KEY)\
    , GetQualifiedName(KEY,PTGNULL)\
    , ORDER(ReportF(NOTE,COORDREF,MESG,StringTable(DFLT_SYM)),\
            PTGId(DFLT_SYM))\
    )

RULE rField: Field ::= Label FieldType FieldName FieldNumber FieldOptions COMPUTE
  %// label can be empty in v3

  Field.field_ptg = PTGField(FieldName.sym, FieldType.sym, PTGId(Label.sym));

  %// TODO: do something with Field default in optional fields ?
  % // Field.field_ptg = PTGFieldWithDefault(FieldName.sym, FieldType.sym, PTGAsIs("optional"), FieldDefault.sym);

  %// collect use-def relations between fields and message/enum/group definitions
  %// no name analysis carried out; we assume that FieldType.sym is defined
  Field.field_relation_ptg =
    IF( FieldType.is_custom
      /*, PTGRelationUsing(INCLUDING (Message.name, Extend.messageType), FieldType.sym, PTGId(Label.sym))*/
      , PTGRelationUsing(INCLUDING (Message.qualified_name_ptg, Extend.qualified_name_ptg),
                         /*GetQualifiedName(FieldType.custom_type_key, DEFAULT_SYM("unresolved field type '%s'", FieldType.sym)), %// default to unresolved name*/
                         lazy_GetQualifiedName(FieldType.custom_type_key, FieldType.sym, "unresolved field type '%s'"), %// default to unresolved name
                         PTGId(Label.sym))
      , PTGNULL );
END;

%// enum fields have special visualization im PUML
RULE rEnumField: EnumField ::= EnumFieldName FieldNumber EnumFieldOptions COMPUTE
  EnumField.puml_fields_ptg_chn =
    PTGNlSeq(EnumField.puml_fields_ptg_chn, PTGEnumItem(EnumFieldName.sym));
END;

RULE rMap: Map ::= MapKeyType MapValType MapName FieldNumber FieldOptions COMPUTE
  
    Map.field_ptg = PTGMapField(MapName.sym, MapKeyType.sym, MapValType.sym);

    Map.field_relation_ptg =
      IF( MapValType.is_custom
        /*, PTGRelationUsing(INCLUDING (Message.name, Extend.messageType), MapValType.sym, PTGAsIs("map value"))*/
        , PTGRelationUsing(INCLUDING (Message.qualified_name_ptg, Extend.qualified_name_ptg),
                           lazy_GetQualifiedName(MapValType.custom_type_key, MapValType.sym, "unresolved map value type '%s'"), %// default to unresolved name
                           PTGAsIs("map value"))
        , PTGNULL );
END;

%// OneOf is a union field within a Message
RULE rOneOf: OneOf ::= OneOfName OneOfBody COMPUTE 

  OneOf.name = OneOfName.sym;

  OneOf.field_ptg = PTGOneOf(OneOfName.sym, CONSTITUENTS OneOfField.field_ptg WITH (PTGNode,PTGNlSeq,IDENTICAL,PTGNull));

  OneOf.field_relation_ptg = CONSTITUENTS OneOfField.field_relation_ptg WITH (PTGNode,PTGNlSeq,IDENTICAL,PTGNull);
END;

%// OneOfField is a variant (sub-field) within a OneOf union field
SYMBOL OneOfField: field_ptg: PTGNode SYNT;
SYMBOL OneOfField: field_relation_ptg: PTGNode SYNT;
RULE rOneOfField: OneOfField ::= FieldType FieldName FieldNumber FieldOptions COMPUTE 

  OneOfField.field_ptg = PTGField(FieldName.sym, FieldType.sym, PTGNULL);

  %// oneof variants may be custom types
  OneOfField.field_relation_ptg = 
    IF ( FieldType.is_custom
       /*, PTGRelationUsing( INCLUDING (Message.name, Extend.messageType), FieldType.sym, PTGoneofVariant(INCLUDING OneOf.name))*/
       , PTGRelationUsing( INCLUDING (Message.qualified_name_ptg, Extend.qualified_name_ptg),
                           lazy_GetQualifiedName(FieldType.custom_type_key, FieldType.sym, "unresolved oneof field type '%s'"), %// default to unresolved name
                           PTGoneofVariant(INCLUDING OneOf.name))
       , PTGNULL
       );
END;
#undef lazy_GetQualifiedName

CLASS SYMBOL hasSym: sym: int SYNT;
SYMBOL ident INHERITS hasSym COMPUTE
  SYNT.sym = TERM;
END;

CLASS SYMBOL derivedFromIdent INHERITS hasSym COMPUTE
  SYNT.sym=CONSTITUENT ident.sym;
END;
  
SYMBOL MessageName   INHERITS hasSym, derivedFromIdent END;
SYMBOL EnumName      INHERITS hasSym, derivedFromIdent END;
SYMBOL FieldName     INHERITS hasSym, derivedFromIdent END;
SYMBOL EnumItemName  INHERITS hasSym, derivedFromIdent END;
SYMBOL EnumFieldName INHERITS hasSym, derivedFromIdent END;
SYMBOL MapKeyType    INHERITS hasSym COMPUTE SYNT.sym=CONSTITUENT PrimitiveType.sym; END;
SYMBOL MapValType    INHERITS hasSym COMPUTE SYNT.sym=CONSTITUENT FieldType.sym; END;
SYMBOL MapName       INHERITS hasSym, derivedFromIdent END;
SYMBOL OneOfName     INHERITS hasSym, derivedFromIdent END;
SYMBOL PrimitiveType INHERITS hasSym END; %// computed below

SYMBOL PackageName INHERITS hasSym COMPUTE
  SYNT.sym = CONSTITUENTS ident.sym WITH(int,concat_id_with_dot,IDENTICAL,ZERO);
END;

SYMBOL MessageType   INHERITS hasSym COMPUTE
  SYNT.sym =
    concat_id( CONSTITUENT DotOrNot.sym, /* prepend optional dot */
               CONSTITUENTS ident.sym WITH(int,concat_id_with_dot,IDENTICAL,ZERO) );
END;

SYMBOL Label         INHERITS hasSym END;
RULE rLabel_empty:    Label ::=            COMPUTE Label.sym = ensure_idn("(optional)"); END; /* empty label in v3 defaults to optional */
RULE rLabel_required: Label ::= 'required' COMPUTE Label.sym = ensure_idn("required"); END;
RULE rLabel_optional: Label ::= 'optional' COMPUTE Label.sym = ensure_idn("optional"); END;
RULE rLabel_repeated: Label ::= 'repeated' COMPUTE Label.sym = ensure_idn("repeated"); END;

SYMBOL FieldType     INHERITS hasSym END;
RULE rFieldType_is_prim: FieldType ::= PrimitiveType COMPUTE 
  FieldType.sym = PrimitiveType.sym;
  %//FieldType.is_custom = 0;
END;

RULE rFieldType_is_message: FieldType ::= MessageType COMPUTE
  FieldType.sym = MessageType.sym;
  %//FieldType.is_custom = 1;
END;

/* TODO: deprecate */
CLASS SYMBOL customizableType: is_custom: int /*Binding*/ SYNT;
CLASS SYMBOL customizableType: custom_type_key: DefTableKey SYNT;
CLASS SYMBOL customizableType COMPUTE
  /** lookup */
  /* SYNT.is_custom = BindingInEnv(INCLUDING ROOTCLASS.custom_types, THIS.sym); */
  /*printf("DEBUG: Type %s is custom %d\n",StringTable(THIS.sym), THIS.is_custom);*/
  SYNT.is_custom = CONSTITUENTS ident.sym WITH (int,ADD,IDENTICAL,ZERO);

  /* or NoKey */
  SYNT.custom_type_key = KeyOf(BindingInEnv(INCLUDING ROOTCLASS.custom_types, THIS.sym));
END;

SYMBOL FieldType  INHERITS customizableType END;
SYMBOL MapValType INHERITS customizableType END;


SYMBOL DotOrNot INHERITS hasSym END;
RULE rDot:    DotOrNot ::= '.' COMPUTE DotOrNot.sym = ensure_idn("."); END;
RULE rNotDot: DotOrNot ::=     COMPUTE DotOrNot.sym = 0; END;


RULE rPrimitiveType_int32:    PrimitiveType ::= 'int32'    COMPUTE PrimitiveType.sym=ensure_idn("int32");    END;
RULE rPrimitiveType_int64:    PrimitiveType ::= 'int64'    COMPUTE PrimitiveType.sym=ensure_idn("int64");    END;
RULE rPrimitiveType_uint32:   PrimitiveType ::= 'uint32'   COMPUTE PrimitiveType.sym=ensure_idn("uint32");   END;
RULE rPrimitiveType_uint64:   PrimitiveType ::= 'uint64'   COMPUTE PrimitiveType.sym=ensure_idn("uint64");   END;
RULE rPrimitiveType_sint32:   PrimitiveType ::= 'sint32'   COMPUTE PrimitiveType.sym=ensure_idn("sint32");   END;
RULE rPrimitiveType_sint64:   PrimitiveType ::= 'sint64'   COMPUTE PrimitiveType.sym=ensure_idn("sint64");   END;
RULE rPrimitiveType_fixed32:  PrimitiveType ::= 'fixed32'  COMPUTE PrimitiveType.sym=ensure_idn("fixed32");  END;
RULE rPrimitiveType_fixed64:  PrimitiveType ::= 'fixed64'  COMPUTE PrimitiveType.sym=ensure_idn("fixed64");  END;
RULE rPrimitiveType_sfixed32: PrimitiveType ::= 'sfixed32' COMPUTE PrimitiveType.sym=ensure_idn("sfixed32"); END;
RULE rPrimitiveType_sfixed64: PrimitiveType ::= 'sfixed64' COMPUTE PrimitiveType.sym=ensure_idn("sfixed64"); END;
RULE rPrimitiveType_bool:     PrimitiveType ::= 'bool'     COMPUTE PrimitiveType.sym=ensure_idn("bool");     END;
RULE rPrimitiveType_float:    PrimitiveType ::= 'float'    COMPUTE PrimitiveType.sym=ensure_idn("float");    END;
RULE rPrimitiveType_double:   PrimitiveType ::= 'double'   COMPUTE PrimitiveType.sym=ensure_idn("double");   END;
RULE rPrimitiveType_string:   PrimitiveType ::= 'string'   COMPUTE PrimitiveType.sym=ensure_idn("string");   END;
RULE rPrimitiveType_bytes:    PrimitiveType ::= 'bytes'    COMPUTE PrimitiveType.sym=ensure_idn("bytes");    END;
