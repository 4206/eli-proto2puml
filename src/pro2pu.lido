/* TODO: syntax level 3 */
/* TODO: collect groups */
/* TODO: collect oneof */
/* TODO: remove package if no package is given */
/* TODO: clp for include directories */

/* OK: collect type name */
/* TODO: test type name collection with dotted type names */

/**********/

CHAIN puml_ptg_chn: PTGNode;             /* collect message / enum decls */
CHAIN puml_fields_ptg_chn: PTGNode;      /* collect fields within decls */
CHAIN puml_relations_ptg_chn: PTGNode;   /* collect nesting relations */ 
CHAIN custom_types_env_chn: Environment; /* collect type names */


CLASS SYMBOL ROOTCLASS: custom_types: Environment SYNT;
CLASS SYMBOL ROOTCLASS COMPUTE

  /* start collecting uml lines */
  CHAINSTART HEAD.puml_ptg_chn = PTGNULL;
  CHAINSTART HEAD.puml_fields_ptg_chn = PTGNULL;
  CHAINSTART HEAD.puml_relations_ptg_chn = PTGNULL;
  /* print collected uml lines */
  PTGOut(
    PTGPUML( TAIL.puml_ptg_chn )
  );

  /** TODO: collect full qualified path instead of just the name */
  CHAINSTART HEAD.custom_types_env_chn = NewEnv();
  SYNT.custom_types = TAIL.custom_types_env_chn;
END;

SYMBOL ProtoDoc COMPUTE
  /* TODO: replace add
  * can there be multiple packages per file? */
  SYNT.puml_ptg_chn = /*PTGNlSeq(THIS.puml_ptg_chn,
                        PTGPackage( CONSTITUENTS Package.name WITH (int,ADD,IDENTICAL,ZERO),
                                    PTGNlSeq(TAIL.puml_ptg_chn, TAIL.puml_relations_ptg_chn)
                                  )
                      );*/

                      PTGNlSeq(THIS.puml_ptg_chn,
                        /* wrap into package only if there is a package name given */
                        IF ( CONSTITUENTS Package.name WITH (int,ADD,IDENTICAL,ZERO)
                           , PTGPackage( CONSTITUENTS Package.name WITH (int,ADD,IDENTICAL,ZERO),
                                         PTGNlSeq(TAIL.puml_ptg_chn, TAIL.puml_relations_ptg_chn)
                                       )
                           , PTGNlSeq(TAIL.puml_ptg_chn, TAIL.puml_relations_ptg_chn)
                           )
                      );


  HEAD.puml_ptg_chn = PTGNULL;
  HEAD.puml_fields_ptg_chn = PTGNULL;
  HEAD.puml_relations_ptg_chn = PTGNULL;
END;

CLASS SYMBOL hasName: name: int SYNT;

SYMBOL Package INHERITS hasName END;
SYMBOL Message INHERITS hasName END;
SYMBOL Enum    INHERITS hasName END;


RULE rPackage: Package ::= PackageName COMPUTE
  Package.name = PackageName.sym;
END;
SYMBOL Package COMPUTE
  /*SYNT.puml_ptg_chn = PTGPackage(CONSITUTENT PackageName.sym, TAIL.puml_ptg_chn);*/

  /*TODO: handle multiple packages and imports */
  /*HEAD.puml_relations_ptg_chn = PTGNULL;*/  
END;


RULE rMessage: Message ::= MessageName MessageBody COMPUTE
  Message.name = MessageName.sym;
END;
SYMBOL Message COMPUTE
  /*printf("DEBUG: looking at message %s\n",StringTable(THIS.name));*/
  /* pass empty chain down, let subtree fill it  */
  HEAD.puml_fields_ptg_chn = PTGNULL;
  /* bridge fields over subtree, in case of nested messages */
  SYNT.puml_fields_ptg_chn = THIS.puml_fields_ptg_chn;

  SYNT.puml_ptg_chn = PTGNlSeq(TAIL.puml_ptg_chn, PTGClass(THIS.name, TAIL.puml_fields_ptg_chn));

  HEAD.custom_types_env_chn = EnvOf(BindIdn(THIS.custom_types_env_chn,THIS.name));
END;

RULE rEnum: Enum ::= EnumName EnumBody COMPUTE
  Enum.name = EnumName.sym;
END;
SYMBOL Enum COMPUTE
/* pass empty chain down, let subtree fill it  */
  HEAD.puml_fields_ptg_chn = PTGNULL;
  /* bridge fields over subtree, in case of nested messages */
  SYNT.puml_fields_ptg_chn = THIS.puml_fields_ptg_chn;

  /* bridge over subtree */
  SYNT.puml_ptg_chn = PTGNlSeq(TAIL.puml_ptg_chn, PTGEnum(THIS.name, TAIL.puml_fields_ptg_chn));

  HEAD.custom_types_env_chn = EnvOf(BindIdn(THIS.custom_types_env_chn,THIS.name));
END;


SYMBOL Field: field_ptg: PTGNode SYNT;
SYMBOL Field: field_relation_ptg: PTGNode SYNT; /* is PTGNULL if type is primitve */
SYMBOL Field COMPUTE
  /* contribution to chain */
  SYNT.puml_fields_ptg_chn =
    PTGNlSeq(THIS.puml_fields_ptg_chn, THIS.field_ptg);

  /* add a type relation of parent uses fieldtype */
  SYNT.puml_relations_ptg_chn =
    PTGNlSeq(THIS.puml_relations_ptg_chn, THIS.field_relation_ptg);
END;

RULE rRequiredField: Field ::= FieldType FieldName FieldNumber FieldOptions COMPUTE
  Field.field_ptg = PTGField(FieldName.sym, FieldType.sym, PTGAsIs("required"));

  Field.field_relation_ptg =
    IF( FieldType.is_custom
      , PTGRelationUsing(INCLUDING Message.name, FieldType.sym, PTGAsIs("required"))
      , PTGNULL );
END;

RULE rOptionalField: Field ::= FieldType FieldName FieldNumber FieldOptions COMPUTE
  /*Field.field_ptg = PTGFieldWithDefault(FieldName.sym, FieldType.sym, PTGAsIs("optional"), FieldDefault.sym);*/
Field.field_ptg = PTGField(FieldName.sym, FieldType.sym, PTGAsIs("optional"));
  /* TODO: do something with FieldDefault */

  Field.field_relation_ptg =
    IF( FieldType.is_custom
      , PTGRelationUsing(INCLUDING Message.name, FieldType.sym, PTGAsIs("optional"))
      , PTGNULL );
END;

RULE rRepeatedField: Field ::= FieldType FieldName FieldNumber FieldOptions COMPUTE
  Field.field_ptg = PTGField(FieldName.sym, FieldType.sym, PTGAsIs("repeated"));

  Field.field_relation_ptg =
    IF( FieldType.is_custom
      , PTGRelationUsing(INCLUDING Message.name, FieldType.sym, PTGAsIs("repeated"))
      , PTGNULL );
END;

RULE rEnumElem: EnumElem ::= EnumKey EnumId EnumElemOptions COMPUTE
  EnumElem.puml_fields_ptg_chn =
    PTGNlSeq(EnumElem.puml_fields_ptg_chn, PTGEnumItem(EnumKey.sym));
END;


CLASS SYMBOL hasSym: sym: int SYNT;
CLASS SYMBOL hasSym COMPUTE
  SYNT.sym = TERM;
END;

SYMBOL ident INHERITS hasSym END; /* TODO: rename head */

SYMBOL PackageName INHERITS hasSym COMPUTE
  SYNT.sym = CONSTITUENTS ident.sym WITH(int,concat_id_with_dot,IDENTICAL,ZERO);
END;
SYMBOL MessageName INHERITS hasSym END;
SYMBOL EnumName INHERITS hasSym END;
SYMBOL FieldName INHERITS hasSym END;
SYMBOL FieldType INHERITS hasSym COMPUTE /* TODO */ END;
SYMBOL EnumItemName INHERITS hasSym END;
SYMBOL EnumKey INHERITS hasSym END;
SYMBOL EnumId INHERITS hasSym END;

RULE rFieldType01: FieldType ::= 'double' COMPUTE FieldType.sym = ensure_idn("double"); END;
RULE rFieldType02: FieldType ::= 'float' COMPUTE FieldType.sym = ensure_idn("float"); END;
RULE rFieldType03: FieldType ::= 'int32' COMPUTE FieldType.sym = ensure_idn("int32"); END;
RULE rFieldType04: FieldType ::= 'int64' COMPUTE FieldType.sym = ensure_idn("int64"); END;
RULE rFieldType05: FieldType ::= 'uint32' COMPUTE FieldType.sym = ensure_idn("uint32"); END;
RULE rFieldType06: FieldType ::= 'uint64' COMPUTE FieldType.sym = ensure_idn("uint64"); END;
RULE rFieldType07: FieldType ::= 'sint32' COMPUTE FieldType.sym = ensure_idn("sint32"); END;
RULE rFieldType08: FieldType ::= 'sint64' COMPUTE FieldType.sym = ensure_idn("sint64"); END;
RULE rFieldType09: FieldType ::= 'fixed32' COMPUTE FieldType.sym = ensure_idn("fixed32"); END;
RULE rFieldType10: FieldType ::= 'fixed64' COMPUTE FieldType.sym = ensure_idn("fixed64"); END;
RULE rFieldType11: FieldType ::= 'sfixed32' COMPUTE FieldType.sym = ensure_idn("sfixed32"); END;
RULE rFieldType12: FieldType ::= 'sfixed64' COMPUTE FieldType.sym = ensure_idn("sfixed64"); END;
RULE rFieldType13: FieldType ::= 'bool' COMPUTE FieldType.sym = ensure_idn("bool"); END;
RULE rFieldType14: FieldType ::= 'string' COMPUTE FieldType.sym = ensure_idn("string"); END;
RULE rFieldType15: FieldType ::= 'bytes' COMPUTE FieldType.sym = ensure_idn("bytes"); END;
RULE rFieldType16: FieldType ::= message_or_enum_type2 COMPUTE
  FieldType.sym =
    concat_id( CONSTITUENT DotOrNot.sym,
               CONSTITUENTS ident.sym WITH(int,concat_id_with_dot,IDENTICAL,ZERO) );

END;

SYMBOL FieldType: is_custom: Binding SYNT;
SYMBOL FieldType COMPUTE
  /** lookup */
  SYNT.is_custom = BindingInEnv(INCLUDING ROOTCLASS.custom_types, THIS.sym);
  /*printf("DEBUG: Type %s is custom %d\n",StringTable(THIS.sym), THIS.is_custom);*/
END;

SYMBOL DotOrNot INHERITS hasSym END;
RULE rDot:    DotOrNot ::= '.' COMPUTE DotOrNot.sym = ensure_idn("."); END;
RULE rNotDot: DotOrNot ::=     COMPUTE DotOrNot.sym = 0; END;