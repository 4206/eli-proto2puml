/* DONE: syntax level 3 */
/* TODO: collect groups */
/* TODO: collect oneof */
/* DONE: remove package if no package is given */
/* TODO: clp for include directories */
/* TODO: collect depedencies between imported packages */

/* DONE: collect type name */
/* TODO: test type name collection with dotted type names */

/**********/

CHAIN puml_ptg_chn: PTGNode;             /* collect message / enum decls */
CHAIN puml_fields_ptg_chn: PTGNode;      /* collect fields within decls */
CHAIN puml_relations_ptg_chn: PTGNode;   /* collect nesting relations */ 
CHAIN custom_types_env_chn: Environment; /* collect type names */


CLASS SYMBOL ROOTCLASS: custom_types: Environment SYNT;
CLASS SYMBOL ROOTCLASS COMPUTE

  /* start collecting uml lines */
  CHAINSTART HEAD.puml_ptg_chn = PTGNULL;
  CHAINSTART HEAD.puml_fields_ptg_chn = PTGNULL;
  CHAINSTART HEAD.puml_relations_ptg_chn = PTGNULL;
  /* print collected uml lines */
  PTGOut(
    PTGPUML( TAIL.puml_ptg_chn )
  );

  /** TODO: collect full qualified path instead of just the name */
  CHAINSTART HEAD.custom_types_env_chn = NewEnv();
  SYNT.custom_types = TAIL.custom_types_env_chn;
END;

SYMBOL ProtoDoc COMPUTE
  /* TODO: replace add
  * can there be multiple packages per file? */
  SYNT.puml_ptg_chn = /*PTGNlSeq(THIS.puml_ptg_chn,
                        PTGPackage( CONSTITUENTS Package.name WITH (int,ADD,IDENTICAL,ZERO),
                                    PTGNlSeq(TAIL.puml_ptg_chn, TAIL.puml_relations_ptg_chn)
                                  )
                      );*/

                      PTGNlSeq(THIS.puml_ptg_chn,
                        /* wrap into package only if there is a package name given */
                        IF ( CONSTITUENTS Package.name WITH (int,ADD,IDENTICAL,ZERO)
                           , PTGPackage( CONSTITUENTS Package.name WITH (int,ADD,IDENTICAL,ZERO),
                                         PTGNlSeq(TAIL.puml_ptg_chn, TAIL.puml_relations_ptg_chn)
                                       )
                           , PTGNlSeq(TAIL.puml_ptg_chn, TAIL.puml_relations_ptg_chn)
                           )
                      );


  HEAD.puml_ptg_chn = PTGNULL;
  HEAD.puml_fields_ptg_chn = PTGNULL;
  HEAD.puml_relations_ptg_chn = PTGNULL;
END;

CLASS SYMBOL hasName: name: int SYNT;

SYMBOL Package INHERITS hasName END;
SYMBOL Message INHERITS hasName END;
SYMBOL Enum    INHERITS hasName END;


RULE rPackage: Package ::= PackageName COMPUTE
  Package.name = PackageName.sym;
END;
SYMBOL Package COMPUTE
  /*SYNT.puml_ptg_chn = PTGPackage(CONSITUTENT PackageName.sym, TAIL.puml_ptg_chn);*/

  /*TODO: handle multiple packages and imports */
  /*HEAD.puml_relations_ptg_chn = PTGNULL;*/  
END;


RULE rMessage: Message ::= MessageName MessageBody COMPUTE
  /* declares a new type of .name */
  Message.name = MessageName.sym;
END;
SYMBOL Message COMPUTE
  /*printf("DEBUG: looking at message %s\n",StringTable(THIS.name));*/
  /* pass empty chain down, let subtree fill it  */
  HEAD.puml_fields_ptg_chn = PTGNULL;
  /* bridge fields over subtree, in case of nested messages */
  SYNT.puml_fields_ptg_chn = THIS.puml_fields_ptg_chn;

  SYNT.puml_ptg_chn = PTGNlSeq(TAIL.puml_ptg_chn, PTGClass(THIS.name, TAIL.puml_fields_ptg_chn));

  HEAD.custom_types_env_chn = EnvOf(BindIdn(THIS.custom_types_env_chn,THIS.name));
END;

RULE rEnum: Enum ::= EnumName EnumBody COMPUTE
  Enum.name = EnumName.sym;
END;
SYMBOL Enum COMPUTE
/* pass empty chain down, let subtree fill it  */
  HEAD.puml_fields_ptg_chn = PTGNULL;
  /* bridge fields over subtree, in case of nested messages */
  SYNT.puml_fields_ptg_chn = THIS.puml_fields_ptg_chn;

  /* bridge over subtree */
  SYNT.puml_ptg_chn = PTGNlSeq(TAIL.puml_ptg_chn, PTGEnum(THIS.name, TAIL.puml_fields_ptg_chn));

  HEAD.custom_types_env_chn = EnvOf(BindIdn(THIS.custom_types_env_chn,THIS.name));
END;


SYMBOL Field: field_ptg: PTGNode SYNT;
SYMBOL Field: field_relation_ptg: PTGNode SYNT; /* is PTGNULL if type is primitve */
SYMBOL Field COMPUTE
  /* contribution to chain */
  SYNT.puml_fields_ptg_chn =
    PTGNlSeq(THIS.puml_fields_ptg_chn, THIS.field_ptg);

  /* add a type relation of parent uses fieldtype */
  SYNT.puml_relations_ptg_chn =
    PTGNlSeq(THIS.puml_relations_ptg_chn, THIS.field_relation_ptg);
END;

RULE rField: Field ::= Label FieldType FieldName FieldNumber FieldOptions COMPUTE
  %// label can be empty in v3

  Field.field_ptg = PTGField(FieldName.sym, FieldType.sym, PTGId(Label.sym));

  %// TODO: do something with Field default in optional fields ?
  % // Field.field_ptg = PTGFieldWithDefault(FieldName.sym, FieldType.sym, PTGAsIs("optional"), FieldDefault.sym);

  %// collect use-def relations between fields and message/enum/group definitions
  %// no name analysis carried out; we assume that FieldType.sym is defined
  Field.field_relation_ptg =
    IF( FieldType.is_custom
      , PTGRelationUsing(INCLUDING (Message.name, Extend.messageType), FieldType.sym, PTGId(Label.sym))
      , PTGNULL );
END;

RULE rEnumField: EnumField ::= EnumFieldName FieldNumber EnumFieldOptions COMPUTE
  EnumField.puml_fields_ptg_chn =
    PTGNlSeq(EnumField.puml_fields_ptg_chn, PTGEnumItem(EnumFieldName.sym));
END;


CLASS SYMBOL hasSym: sym: int SYNT;
CLASS SYMBOL hasSym COMPUTE
  SYNT.sym = TERM;
END;

SYMBOL ident INHERITS hasSym END; /* TODO: rename head */

SYMBOL PackageName INHERITS hasSym COMPUTE
  SYNT.sym = CONSTITUENTS ident.sym WITH(int,concat_id_with_dot,IDENTICAL,ZERO);
END;
SYMBOL MessageName   INHERITS hasSym COMPUTE SYNT.sym=CONSTITUENT ident.sym; END;
SYMBOL EnumName      INHERITS hasSym COMPUTE SYNT.sym=CONSTITUENT ident.sym; END;
SYMBOL FieldName     INHERITS hasSym COMPUTE SYNT.sym=CONSTITUENT ident.sym; END;
SYMBOL FieldType     INHERITS hasSym COMPUTE /* TODO */ END;
SYMBOL EnumItemName  INHERITS hasSym COMPUTE SYNT.sym=CONSTITUENT ident.sym; END;
SYMBOL EnumFieldName INHERITS hasSym COMPUTE SYNT.sym=CONSTITUENT ident.sym; END;
SYMBOL MessageType   INHERITS hasSym COMPUTE
  SYNT.sym =
    concat_id( CONSTITUENT DotOrNot.sym, /* prepend optional dot */
               CONSTITUENTS ident.sym WITH(int,concat_id_with_dot,IDENTICAL,ZERO) );
END;

SYMBOL Label         INHERITS hasSym END;
RULE rLabel_empty: Label ::= COMPUTE Label.sym = 0; END; /* empty label in v3 */
RULE rLabel_required: Label ::= 'required' COMPUTE Label.sym = ensure_idn("required"); END;
RULE rLabel_optional: Label ::= 'optional' COMPUTE Label.sym = ensure_idn("optional"); END;
RULE rLabel_repeated: Label ::= 'repeated' COMPUTE Label.sym = ensure_idn("repeated"); END;

SYMBOL FieldType: is_primitive: int SYNT;
SYMBOL FieldType COMPUTE SYNT.is_primitive = 0; END; /* default to non-primitive */

#define P() FieldType.is_primitive = 1
 RULE rFieldType01: FieldType ::= 'double' COMPUTE FieldType.sym = ensure_idn("double"); P(); END;
 RULE rFieldType02: FieldType ::= 'float' COMPUTE FieldType.sym = ensure_idn("float"); P(); END;
RULE rFieldType03: FieldType ::= 'int32' COMPUTE FieldType.sym = ensure_idn("int32"); P(); END;
RULE rFieldType04: FieldType ::= 'int64' COMPUTE FieldType.sym = ensure_idn("int64"); P(); END;
RULE rFieldType05: FieldType ::= 'uint32' COMPUTE FieldType.sym = ensure_idn("uint32"); P(); END;
RULE rFieldType06: FieldType ::= 'uint64' COMPUTE FieldType.sym = ensure_idn("uint64"); P(); END;
RULE rFieldType07: FieldType ::= 'sint32' COMPUTE FieldType.sym = ensure_idn("sint32"); P(); END;
RULE rFieldType08: FieldType ::= 'sint64' COMPUTE FieldType.sym = ensure_idn("sint64"); P(); END;
RULE rFieldType09: FieldType ::= 'fixed32' COMPUTE FieldType.sym = ensure_idn("fixed32"); P(); END;
RULE rFieldType10: FieldType ::= 'fixed64' COMPUTE FieldType.sym = ensure_idn("fixed64"); P(); END;
RULE rFieldType11: FieldType ::= 'sfixed32' COMPUTE FieldType.sym = ensure_idn("sfixed32"); P(); END;
RULE rFieldType12: FieldType ::= 'sfixed64' COMPUTE FieldType.sym = ensure_idn("sfixed64"); P(); END;
RULE rFieldType13: FieldType ::= 'bool' COMPUTE FieldType.sym = ensure_idn("bool"); P(); END;
RULE rFieldType14: FieldType ::= 'string' COMPUTE FieldType.sym = ensure_idn("string"); P(); END;
 RULE rFieldType15: FieldType ::= 'bytes' COMPUTE FieldType.sym = ensure_idn("bytes"); P(); END;
RULE rFieldType16: FieldType ::= message_or_enum_type2 COMPUTE
  FieldType.sym =
    concat_id( CONSTITUENT DotOrNot.sym, /* prepend optional dot */
               CONSTITUENTS ident.sym WITH(int,concat_id_with_dot,IDENTICAL,ZERO) );

END;

SYMBOL FieldType: is_custom: Binding SYNT;
SYMBOL FieldType COMPUTE
  /** lookup */
  SYNT.is_custom = BindingInEnv(INCLUDING ROOTCLASS.custom_types, THIS.sym);
  /*printf("DEBUG: Type %s is custom %d\n",StringTable(THIS.sym), THIS.is_custom);*/
END;
#undef P

SYMBOL DotOrNot INHERITS hasSym END;
RULE rDot:    DotOrNot ::= '.' COMPUTE DotOrNot.sym = ensure_idn("."); END;
RULE rNotDot: DotOrNot ::=     COMPUTE DotOrNot.sym = 0; END;

SYMBOL Extend: messageType: int SYNT;
RULE rExtend: Extend ::= MessageType ExtendBody COMPUTE
  Extend.messageType = MessageType.sym;
END;
